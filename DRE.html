<script type="module">
  import { db } from './assets/firebase-config.js';
  import { ref, onValue, get, child, update } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js';

  // ===== Datas base (sempre fecha o MÊS ANTERIOR) =====
  const hoje = new Date();
  const ANO  = hoje.getFullYear();
  const ANO_ANT = ANO - 1;
  const MES_ATUAL = hoje.getMonth();          // 0..11
  const MES_BASE  = (MES_ATUAL - 1 + 12) % 12;// mês anterior (0..11)
  const ANO_BASE  = (MES_ATUAL === 0) ? ANO_ANT : ANO;

  // ===== Caches mínimos =====
  const categorias = new Map();     // id -> { nome, centro, tipo, dre_* , dre_valor }
  const regrasHist = new Map();     // "YYYYMM" -> Map(catId -> regra/vigência)
  const cons = { [ANO_ANT]: null, [ANO]: null };

  // ===== Utils =====
  const yyyymm = (y, m0)=> `${y}-${String(m0+1).padStart(2,'0')}`;
  const parseNumber = (v)=>{
    if (typeof v === 'number') return v;
    if (v && typeof v === 'object'){
      const cands = [v.valor, v.total, v.amount, v.Valor, v.valorReal, v.valor_liquido, v.valorBruto];
      for (const c of cands){ const n = Number(c); if (!Number.isNaN(n)) return n; }
    }
    const n = Number(v); return Number.isNaN(n) ? 0 : n;
  };
  const isCompras = (cat)=> String(cat?.nome||'').trim().toLowerCase()==='compras';

  // Regra efetiva (histórico > cadastro atual)
  function getRegraEfetiva(catId, y, m0){
    const ym   = `${y}${String(m0+1).padStart(2,'0')}`;
    const hist = regrasHist.get(ym)?.get(catId);
    const cad  = categorias.get(catId)||{};
    return {
      dre_regra:           hist?.dre_regra ?? cad.dre_regra ?? '',
      dre_media_janela:    hist?.dre_media_janela ?? cad.dre_media_janela ?? null,
      dre_percentual_base: hist?.dre_percentual_base ?? cad.dre_percentual_base ?? null,
      dre_valor:           hist?.dre_valor ?? cad.dre_valor ?? null
    };
  }

  // Valor do CONSOLIDADO por categoria no mês
  function valConsolidado(catId, y, m0){
    const node = cons[y]; if (!node) return 0;
    const mes  = node[m0+1];
    return parseNumber(mes?.[catId] ?? 0);
  }

  // Receita do mês (centro=Receita OU tipo=Entrada)
  function receitaMes(y,m0){
    let soma = 0;
    categorias.forEach((cat,id)=>{
      const centro = (cat.centro||'').toLowerCase();
      const tipo   = (cat.tipo||'').toLowerCase();
      if (centro === 'receita' || tipo === 'entrada'){
        soma += valConsolidado(id,y,m0);
      }
    });
    return soma;
  }

  // Média N meses da própria categoria até (y,m0)
  function mediaCat(catId, y, m0, n){
    if (!n || n<=0) return 0;
    let soma=0, count=0;
    for (let k=0;k<n;k++){
      let yy=y, mm=m0-k;
      if (mm<0){ yy--; mm+=12; }
      if (yy!==ANO && yy!==ANO_ANT) continue;
      soma += valConsolidado(catId, yy, mm); count++;
    }
    return count? (soma/count):0;
  }

  // Valor de DRE no mês por categoria (com regra efetiva)
  function valorDREMes(catId, y, m0){
    const cat   = categorias.get(catId)||{};
    const regra = getRegraEfetiva(catId, y, m0);

    if (regra.dre_regra === 'especial'){
      if (isCompras(cat)){
        // Compras mantém sua lógica atual (competência do consolidado, ou o que você já utiliza no arquivo)
        return valConsolidado(catId, y, m0);
      }
      // Demais categorias especiais usam dre_valor
      const n = Number(regra.dre_valor||0);
      return Number.isFinite(n) ? n : 0;
    }
    if (regra.dre_regra === 'competencia_media'){
      const n = Number(regra.dre_media_janela||0);
      return mediaCat(catId, y, m0, n);
    }
    if (regra.dre_regra === 'competencia_driver'){
      const p = Number(regra.dre_percentual_base||0);
      return p * receitaMes(y,m0);
    }
    // 'caixa' (na sua tela é consolidado do mês) e default:
    return valConsolidado(catId, y, m0);
  }

  // ===== Grava snapshot do mês (não sobrescreve por padrão) =====
  async function fecharDREMes({ano=ANO_BASE, mes0=MES_BASE, forcar=false}={}){
    const ymLabel = yyyymm(ano,mes0); // ex: "2025-09"
    const snapPath = `financeiro/dre_fechado/${ano}/${String(mes0+1).padStart(2,'0')}`;

    // idempotência: não sobrescreve sem forçar
    const existe = await get(child(ref(db), snapPath));
    if (existe.exists() && !forcar){
      alert(`Já existe snapshot de DRE para ${ymLabel}. Nada foi gravado.`);
      return;
    }

    // monta estruturas
    const porCategoria = {};   // { catId: {nome, centro, tipo, regra_usada:{...}, valorMes, valorYTD} }
    const grupos = {          // somatórios por centro
      Receita:      {mes:0, ytd:0},
      CMV:          {mes:0, ytd:0},
      'Despesa Operacional': {mes:0, ytd:0},
      'Despesa Variável':    {mes:0, ytd:0},
      'Despesa Fixa':        {mes:0, ytd:0},
      Investimento: {mes:0, ytd:0},
      Retirada:     {mes:0, ytd:0}
    };

    // YTD (até o mês base)
    const ytdPorCat = (catId)=>{
      let s=0;
      for (let m=0;m<=mes0;m++) s += valorDREMes(catId, ano, m);
      return s;
    };

    // percorre categorias
    categorias.forEach((cat, id)=>{
      const valorMes = valorDREMes(id, ano, mes0);
      const valorYTD = ytdPorCat(id);
      const regra    = getRegraEfetiva(id, ano, mes0);

      porCategoria[id] = {
        nome:   cat.nome || '',
        centro: cat.centro || '',
        tipo:   cat.tipo || '',
        regra_usada: {
          dre_regra: regra.dre_regra || '',
          dre_media_janela: regra.dre_media_janela ?? null,
          dre_percentual_base: regra.dre_percentual_base ?? null,
          dre_valor: regra.dre_valor ?? null
        },
        valorMes,
        valorYTD
      };

      // acumula em grupos (usa o centro cadastrado)
      const centro = (cat.centro || '').trim();
      if (grupos[centro]){
        grupos[centro].mes  += valorMes;
        grupos[centro].ytd  += valorYTD;
      }
    });

    // Resultado
    const soma = (g)=> (grupos[g]?.mes||0);
    const somaY = (g)=> (grupos[g]?.ytd||0);
    const receitaMesV = soma('Receita');
    const receitaYTDV = somaY('Receita');

    const resultadoMes =
      receitaMesV
      - soma('CMV')
      - soma('Despesa Operacional')
      - soma('Despesa Variável')
      - soma('Despesa Fixa')
      - soma('Investimento')
      - soma('Retirada');

    const resultadoYTD =
      receitaYTDV
      - somaY('CMV')
      - somaY('Despesa Operacional')
      - somaY('Despesa Variável')
      - somaY('Despesa Fixa')
      - somaY('Investimento')
      - somaY('Retirada');

    const margemMes  = receitaMesV ? (resultadoMes / receitaMesV) : 0;
    const margemYTD  = receitaYTDV ? (resultadoYTD / receitaYTDV) : 0;

    // payload final
    const payload = {
      meta: {
        ano, mes: mes0+1,
        competenciaBase: true,            // indica que usa competência
        fechadoEm: new Date().toISOString(),
        baseCalculo: 'até o mês anterior',
        origem: 'DRE.html',
      },
      categorias: porCategoria,
      grupos,
      resultado: {
        mes: resultadoMes,
        ytd: resultadoYTD,
        margemMes,
        margemYTD
      }
    };

    await update(ref(db, snapPath), payload);
    alert(`DRE de ${ymLabel} salvo em ${snapPath}.`);
  }

  // ===== Listeners mínimos para termos dados =====
  onValue(ref(db,'financeiro/categorias'), s=>{
    categorias.clear();
    if (s.exists()) s.forEach(ch=> categorias.set(ch.key, ch.val()||{}) );
  });
  onValue(ref(db,'financeiro/regras_dre_historico'), s=>{
    regrasHist.clear();
    if (s.exists()){
      s.forEach(anoSnap=>{
        const y = anoSnap.key;
        anoSnap.forEach(mesSnap=>{
          const m = String(mesSnap.key).padStart(2,'0');
          const map = new Map();
          mesSnap.forEach(catSnap=> map.set(catSnap.key, catSnap.val()||{}) );
          regrasHist.set(`${y}${m}`, map);
        });
      });
    }
  });
  onValue(ref(db,`financeiro/consolidado/${ANO_ANT}`), s=>{ cons[ANO_ANT] = s.exists()? s.val(): null; });
  onValue(ref(db,`financeiro/consolidado/${ANO}`),     s=>{ cons[ANO]     = s.exists()? s.val(): null; });

  // ===== Botão Fechar =====
  const btn = document.getElementById('btnFecharMes');
  if (btn){
    btn.addEventListener('click', ()=> fecharDREMes({forcar:false}));
  }
</script>
